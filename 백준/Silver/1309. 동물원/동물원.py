# f(n)은 비어있는 두 칸 밑에 n개의 칸이 있을 때 배치 가능한 경우의 수이다.
# g(n)은 왼쪽 칸에 사자가 있고, 밑에 n 개의 칸이 있을 때 배치 가능한 경우의 수이다.
# f(n)은 맨 윗 칸을 전부 비워두고 나머지 n-1개의 칸을 배치하는 f(n-1)과
#       맨 윗 칸의 왼쪽 칸에 사자를 배치하고 밑에 있는 n개의 칸을 배치하는 g(n-1)의 두배의 합이다.(좌우 대칭이므로 2배)
# f(n) = f(n-1) + g(n-1) * 2
# g(n)은 두 번째 칸을 비워두고 나머지 n-1개의 칸을 배치하는 f(n-1)과
#       두 번째 칸의 오른쪽에 사자를 배치하고 밑에 있는 n-1개의 칸을 배치하는 g(n-1)의 합이다.(대칭 고려 x)

# g(n) = g(n-1) + f(n-1) = 2 + f(1) + ... f(n-1) / g(n-1)을 f로 계속해서 바꾸면 우항이 된다.

N = int(input())
noLion = [1] * (N+1)
oneLion = [1] * (N+1)
for i in range(1, N+1):
    oneLion[i] = noLion[i-1] + oneLion[i-1]
    noLion[i] = (noLion[i-1] + (2 * oneLion[i-1])) % 9901

print(noLion[N])
